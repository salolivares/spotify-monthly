package main

import (
	"context"
	"fmt"
	"time"

	"github.com/rs/zerolog/log"
	"github.com/zmb3/spotify/v2"
)

// Period defines a time window with a name and a local start/end range.
type Period struct {
	Name       string    // e.g., "August 2025" or "Winter 2025–26"
	StartLocal time.Time // inclusive
	EndLocal   time.Time // exclusive
}

// monthPeriod returns a Period representing a single calendar month.
func monthPeriod(loc *time.Location, year int, month time.Month) Period {
	start := time.Date(year, month, 1, 0, 0, 0, 0, loc)
	end := start.AddDate(0, 1, 0) // first of next month

	return Period{
		Name:       fmt.Sprintf("%s %d", month.String(), year),
		StartLocal: start,
		EndLocal:   end,
	}
}

// seasonPeriod returns the season (meteorological) containing the given month.
// Winter spans two years, so the name is formatted accordingly.
func seasonPeriod(loc *time.Location, year int, month time.Month) Period {
	var start time.Time
	var name string

	switch month {
	case 12:
		start = time.Date(year, time.December, 1, 0, 0, 0, 0, loc)
		name = fmt.Sprintf("Winter %d–%02d", year, (year+1)%100)
	case 1, 2:
		start = time.Date(year-1, time.December, 1, 0, 0, 0, 0, loc)
		name = fmt.Sprintf("Winter %d–%02d", year-1, year%100)
	case 3, 4, 5:
		start = time.Date(year, time.March, 1, 0, 0, 0, 0, loc)
		name = fmt.Sprintf("Spring %d", year)
	case 6, 7, 8:
		start = time.Date(year, time.June, 1, 0, 0, 0, 0, loc)
		name = fmt.Sprintf("Summer %d", year)
	case 9, 10, 11:
		start = time.Date(year, time.September, 1, 0, 0, 0, 0, loc)
		name = fmt.Sprintf("Fall %d", year)
	default:
		panic(fmt.Sprintf("invalid month: %d", month))
	}

	end := start.AddDate(0, 3, 0) // add 3 months to get exclusive end

	return Period{
		Name:       name,
		StartLocal: start,
		EndLocal:   end,
	}
}

// inRangeLocal checks if the given UTC timestamp falls within the Period’s local range.
func inRangeLocal(t time.Time, p Period) bool {
	lt := t.In(p.StartLocal.Location())
	return !lt.Before(p.StartLocal) && lt.Before(p.EndLocal)
}

func runPeriod(ctx context.Context, c *spotify.Client, period Period, makePublic bool) error {
	user, err := c.CurrentUser(ctx)
	if err != nil {
		return err
	}

	likes, err := fetchAllLikes(ctx, c)
	if err != nil {
		return err
	}

	var trackIDs []spotify.ID
	for _, track := range likes {
		parsedTime, err := time.Parse(spotify.TimestampLayout, track.AddedAt)
		if err != nil {
			log.Warn().Err(err).Msgf("Failed to parse AddedAt for track %s", track.Name)
			continue // skip this track if parsing fails
		}

		if inRangeLocal(parsedTime, period) {
			trackIDs = append(trackIDs, track.ID)
			log.Info().Msgf("Adding %s - %s. Added At: %s.", track.Name, track.Album.Name, track.AddedAt)
		}
	}

	if len(trackIDs) == 0 {
		log.Info().Msgf("%s: no tracks for this period", period.Name)
		return nil
	}

	plID, err := ensurePlaylist(ctx, c, user.ID, period.Name, "Autogenerated by some code", makePublic)
	if err != nil {
		return err
	}

	seen, err := getExistingPlaylistTrackIDs(ctx, c, plID)
	if err != nil {
		return err
	}

	// Deduplicate against existing
	var toAdd []spotify.ID
	for _, u := range trackIDs {
		if _, ok := seen[u]; !ok {
			toAdd = append(toAdd, u)
		}
	}

	if len(toAdd) == 0 {
		log.Info().Msgf("%s: up to date (%d tracks already present)", period.Name, len(trackIDs))
		return nil
	}

	if err := addURIsBatched(ctx, c, plID, toAdd); err != nil {
		return err
	}

	log.Info().Msgf("%s: added %d new tracks (total this period: %d)", period.Name, len(toAdd), len(seen)+len(toAdd))

	return nil
}
